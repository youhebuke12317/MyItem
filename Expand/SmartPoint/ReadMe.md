# 智能指针：

C++11 特性: 编译时需要加 -std=c++11

存在于 <memory> 中 

三类指针： shared_ptr / unique_ptr / weak_ptr 

## shared_ptr指针

	shared_ptr多个指针指向相同的对象。

	shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。

	每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。

	shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。

- 初始化问题：
	
	智能指针是个模板类，可以指定类型

	传入指针通过构造函数初始化。也可以使用make_shared函数初始化

	不能将指针直接赋值给一个智能指针，一个是类，一个是指针, 
	例如std::shared_ptr<int> p4 = new int(1);的写法是错误的

- 拷贝和赋值
	
	拷贝使得对象的引用计数增加1

	赋值使得原对象引用计数减1

	当计数为0时，自动释放内存

	后来指向的对象引用计数加1，指向后来的对象。

- get函数获取原始指针

- 注意不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存

- 注意避免循环引用

## unique_ptr的使用

unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。

使得在出现异常的情况下，动态资源能得到释放。

- unique_ptr指针本身的生命周期：
	
	从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，
	
	若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。
	
- unique_ptr指针与其所指对象的关系：

	在智能指针生命周期内，可以改变智能指针所指对象，
	
	如创建智能指针时通过构造函数指定
	
	通过reset方法重新指定
	
	通过release方法释放所有权
	
	通过移动语义转移所有权。

